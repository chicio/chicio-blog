---
title: "Mastering the Core: Data Structures and Algorithms"
description: "A strong foundation in data structures and algorithms is essential. Here’s how I decided to revisit the fundamentals and turn them into my own DSA course."
date: 2025-11-01
image: /images/posts/data-structures-and-algoritms-featured.png
tags: [dsa, data structures and algorithms, algorithms]
authors: [fabrizio_duroni]
---

*A strong foundation in data structures and algorithms is essential. Here’s how I decided to revisit the fundamentals and turn them into my own DSA course.*

---

In the past few months, life and work have kept me quite busy, so I haven’t been publishing much here on the blog.  
Still, that doesn’t mean nothing has changed. In fact, my website went through a full transformation since the beginning of the year:

- migrated from Gatsby to Next.js  
- moved from GitHub Pages to Vercel  
- redesigned the UI completely with a "Matrix-inspired" aesthetic I’d always wanted and loved  

Even if I haven’t written many new posts, I’ve been quite active behind the scenes. 
One thing I’ve been enjoying lately in my free time is solving **LeetCode problems**.  
Why? Because even after almost **20 years in this industry**, and despite the rapid progress of **AI** (which seems ready to automate parts of programming we once considered indispensable), I’ve come to realize that **a solid grasp of algorithms and data structures is still invaluable**.  
A well-grounded understanding of time complexity, memory efficiency, and fundamental problem-solving patterns doesn’t just make you a better engineer, it reshapes the way you *think*.  
Recently, I’ve been following the [Algomaster.io DSA patterns list](https://algomaster.io/practice/dsa-patterns), a curated set of 300 problems created by [Ashish Pratap](https://www.linkedin.com/in/ashishps1/), designed to cover all the essential algorithmic concepts. I’ve already crossed the **200-problem milestone**, and the journey has been amazing so far (even if most of the time I scream at the monitor while saying "why I didn't think about this solution by my own???").  

That’s what inspired me to create **my own mini-course on Data Structures and Algorithms**, following the Algomaster groupings (with some custom additions). 
My goal is to build a **centralized reference**, a place I can come back to when I want to revisit key concepts, without having to dig through countless resources online.
And here’s the twist: unlike years ago, when I’d have spent days writing everything from scratch, this time **AI**, the tool that many fear will replace us, have been an *incredible partner* in building this material faster and more effectively than ever.  
The course is still a **work in progress**, but below you’ll find the topics I’ve already covered. I’ll continue to expand it as I progress through the [Algomaster.io](https://algomaster.io/practice/dsa-patterns) challenges, aiming to eventually complete all 300 problems.

So go ahead, bookmark this page and check back from time to time.  
Whether you’re preparing for interviews, sharpening your fundamentals, or just rediscovering the beauty of algorithms, I hope this journey will inspire you too :heart:.

## Data Structures and Algorithms Course

| Topic | Description |
| ------ | ------------ |
| [**Time and Space Complexity**](/data-structures-and-algorithms/time-and-space-complexity) | Understanding how algorithm performance is measured and why Big-O matters. |
| [**Arrays**](/data-structures-and-algorithms/arrays) | Mastering array traversal, manipulation, and common algorithmic patterns. |
| [**Strings**](/data-structures-and-algorithms/strings) | Efficiently solving problems that deal with text and pattern matching. |
| [**Bit Manipulation**](/data-structures-and-algorithms/bit-manipulation) | Unlocking the power of bits for optimization, encoding, and clever tricks. |
| [**Hash Tables**](/data-structures-and-algorithms/hashtables) | Efficient key-value storage and retrieval with near-constant time lookups. |
| [**Two Pointers**](/data-structures-and-algorithms/two-pointers) | Using two pointers to solve array and string problems efficiently. |
| [**Prefix Sum**](/data-structures-and-algorithms/prefix-sum) | Precomputing cumulative sums to answer range queries quickly. |
| **Sliding Window - Fixed Size (Soon available)** | Maintaining a window of fixed length to compute running results. |
| **Sliding Window - Dynamic Size (Soon available)** | Adjusting window size dynamically for problems like substring search. |
| **Kadane's Algorithm (Soon available)** | Finding maximum subarray sum in linear time. |
| **Matrix (2D Array) (Soon available)** | Solving problems on 2D grids, matrices, and performing transformations. |
| **Linked List (Soon available)** | Singly and doubly linked list operations, in-place reversal, and traversal. |
| **LinkedList In-place Reversal (Soon available)** | Techniques to reverse linked lists partially or fully. |
| **Fast and Slow Pointers (Soon available)** | Detecting cycles, middle elements, and related patterns. |
| **Stacks (Soon available)** | LIFO data structure for expression evaluation, parsing, and monotonic stacks. |
| **Monotonic Stack (Soon available)** | Solving next greater/lesser element problems efficiently. |
| **Queues (Soon available)** | FIFO data structure and applications in BFS and scheduling. |
| **Monotonic Queue (Soon available)** | Optimized sliding window max/min computations. |
| **Bucket Sort (Soon available)** | Sorting and counting problems using bucketization. |
| **Recursion (Soon available)** | Solving problems using self-referential function calls. |
| **Divide and Conquer (Soon available)** | Breaking problems into subproblems and combining results. |
| **Merge Sort (Soon available)** | Classic divide-and-conquer sorting algorithm. |
| **QuickSort / QuickSelect (Soon available)** | Efficient sorting and kth element selection. |
| **Binary Search (Soon available)** | Searching in sorted arrays, variants, and optimizations. |
| **Backtracking (Soon available)** | Generating combinations, permutations, and solving constraint problems. |
| **Tree Traversal - Level Order (Soon available)** | BFS traversal techniques for binary trees. |
| **Tree Traversal - Pre Order (Soon available)** | DFS pre-order traversal and recursion patterns. |
| **Tree Traversal - In Order (Soon available)** | DFS in-order traversal, useful for BSTs. |
| **Tree Traversal - Post-Order (Soon available)** | DFS post-order traversal, useful for tree reconstruction. |
| **BST / Ordered Set (Soon available)** | Binary search trees and ordered data set operations. |
| **Tries (Soon available)** | Prefix trees for efficient string storage and retrieval. |
| **Heaps (Soon available)** | Priority queues and heap-based algorithms. |
| **Two Heaps (Soon available)** | Solving median and top-k problems using two heaps. |
| **Top K Elements (Soon available)** | Finding largest/smallest elements efficiently. |
| **Intervals (Soon available)** | Interval merging, scheduling, and overlap problems. |
| **K-Way Merge (Soon available)** | Merging multiple sorted arrays or lists efficiently. |
| **Data Structure Design (Soon available)** | Designing custom data structures for specific tasks. |
| **Greedy (Soon available)** | Making optimal local choices to reach global solutions. |
| **Depth First Search (DFS) (Soon available)** | Traversing graphs and trees using recursion or stack. |
| **Breadth First Search (BFS) (Soon available)** | Level-wise traversal for shortest paths and connectivity. |
| **Topological Sort (Soon available)** | Ordering nodes in DAGs respecting dependencies. |
| **Union Find (Soon available)** | Disjoint set operations for connectivity and cycle detection. |
| **Minimum Spanning Tree (Soon available)** | MST algorithms like Kruskal and Prim. |
| **Shortest Path (Soon available)** | Dijkstra, Bellman-Ford, and related algorithms. |
| **Eulerian Circuit (Soon available)** | Traversal visiting every edge exactly once. |
| **1-D DP (Soon available)** | Dynamic programming on linear structures. |
| **Knapsack DP (Soon available)** | Solving 0/1 knapsack and subset sum problems. |
| **Unbounded Knapsack DP (Soon available)** | Knapsack problems with unlimited item repetitions. |
| **Longest Increasing Subsequence DP (Soon available)** | Finding increasing subsequences in arrays. |
| **2D (Grid) DP (Soon available)** | DP on grids, path counting, and matrix transformations. |
| **String DP (Soon available)** | DP applied to strings for subsequence and substring problems. |
| **Tree / Graph DP (Soon available)** | Dynamic programming on hierarchical and graph structures. |
| **Bitmask DP (Soon available)** | Using bitmasks to represent subsets in DP. |
| **Digit DP (Soon available)** | Solving problems based on digit positions in numbers. |
| **Probability DP (Soon available)** | DP for expected value and probability problems. |
| **State Machine DP (Soon available)** | DP using states and transitions. |
| **String Matching (Soon available)** | KMP, Rabin-Karp, and other substring search algorithms. |
| **Binary Indexed Tree / Segment Tree (Soon available)** | Range queries and updates efficiently. |
| **Maths / Geometry (Soon available)** | Number theory, combinatorics, and geometric algorithms. |
| **Line Sweep (Soon available)** | Processing events sorted by coordinate for interval problems. |
| **Suffix Array (Soon available)** | Advanced string processing and pattern matching. |