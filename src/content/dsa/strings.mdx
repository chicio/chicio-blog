import { StringVisualization } from "../../components/sections/dsa/components/string-visualization";
import { FrequencyMapChart } from "../../components/sections/dsa/components/frequency-map-chart";

# Strings

Strings are one of the most fundamental data types in computer science.  
They serve as the foundation for text processing, pattern recognition, and encoding/decoding operations in almost every system — from compilers to web applications, databases, and machine learning pipelines.

## What is a string?

A **string** is a sequence of characters, often represented as an array of `char` or a sequence of Unicode code points.  
Strings can store letters, digits, symbols, and whitespace, and are used to represent both human-readable text and machine-readable data (like JSON or XML).

### Immutability vs Mutability

In most modern programming languages, strings are **immutable**, meaning that any operation that appears to modify a string actually creates a **new string in memory**. 
This has important implications for both **time** and **space** complexity when manipulating strings.

```typescript
let s = "hello";
s += " world"; // Creates a new string, old string remains unchanged
``` 

Immutability matters for:
	•	safety, because immutable strings are thread-safe and easier to reason about in concurrent environments.
	•	predictability, because functions that operate on strings cannot inadvertently modify inputs elsewhere in the code.
	•	performance considerations, because every modification creates a new string, which may lead to increased memory allocations and slower concatenation for large strings. Efficient string handling techniques, like using StringBuilder in Java or array joins in JavaScript, are often necessary.


## Internal representation

Internally, strings are often stored as contiguous arrays of characters or bytes, sometimes with additional metadata like length and encoding.
Operations like concatenation, slicing, and replacement may require copying these arrays or adjusting indices depending on mutability.

<StringVisualization />

## Operations and Time Complexity

The **time complexity** of insertion and deletion operations on strings depends heavily on **where the operation occurs** and whether the string is **immutable** or **mutable**:

Insert/Delete at the end of the string:
  - **Immutable strings** (e.g., JavaScript `String`, Python `str`, Java `String`) require creating a **new string** with the added/removed character, often resulting in **O(n)** time.  
  - **Mutable strings** (e.g., C `char[]`, Java `StringBuilder`, Swift `String`) can append or remove characters at the end in **O(1)** time if there is pre-allocated buffer space.  
  - In languages with optimized concatenation (like Python’s `str.join`), sequences of appends can behave almost like **O(1) amortized** per operation.

Insert/Delete in the middle of the string:
  - Regardless of immutability, you need to **shift all subsequent characters** to accommodate the change.  
  - This means the operation always costs **O(n)** in time, where `n` is the length of the string.  

Below you can find a table that summarize all the info above and show the time complexity of common string operations:

| Operation        | Average Case | Worst Case |
|------------------|--------------|------------|
| Access (indexing)| O(1)         | O(1)       |
| Search           | O(n)         | O(n)       |
| Concatenation    | O(n + m)     | O(n + m)   |
| Substring        | O(k)         | O(k)       |
| Comparison       | O(n)         | O(n)       |
| Insert (end)     | O(1)         | O(n)       |
| Insert (middle)  | O(n)         | O(n)       |
| Delete (end)     | O(1)         | O(n)       |
| Delete (middle)  | O(n)         | O(n)       |
| Reverse          | O(n)         | O(n)       |

---
---
---
XXXXXX
## 3. Frequency Counting and Hash Maps

A frequent technique in string problems is **character frequency counting**, often used for:
- Checking **anagrams**
- Detecting **palindromes**
- Building **histograms** for text analysis

Example (TypeScript):

```typescript
function buildFrequencyMap(s: string): Record<string, number> {
  const freq: Record<string, number> = {};
  for (const char of s) {
    freq[char] = (freq[char] ?? 0) + 1;
  }
  return freq;
}
```

<FrequencyMapChart />

This technique runs in **O(n)** time and **O(1)** space (since alphabet size is bounded).


## Pattern Matching

Pattern matching involves searching for substrings within a larger text.

### Naïve Approach
- For each position, compare substring → **O(n × m)**  
- Simple but inefficient for long strings.

### Efficient Algorithms
- **KMP (Knuth–Morris–Pratt):** Preprocesses pattern using prefix table → **O(n + m)**
- **Rabin–Karp:** Hash-based matching → **O(n + m)** average, **O(n × m)** worst case
- **Boyer–Moore:** Skips portions of the text using heuristics → **O(n / m)** average

< PatternMatchingDiagram />

## Techniques

- **Reverse a string** (iterative or recursive)
- **Check palindrome**
- **Find first unique character**
- **Group anagrams**
- **Longest substring without repeating characters** (Sliding window — covered in a future article)

These problems test your understanding of:
- Hash maps (frequency)
- Two-pointer patterns
- String immutability

## Exercises

| Exercise | Technique | Solution |
|----------|-----------|----------|
| [Move Zeroes](https://leetcode.com/problems/move-zeroes/) | Two Pointers | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/arrays/move-zeros.ts) |
| [Majority Element](https://leetcode.com/problems/majority-element/) | Hashing / Boyer-Moore Voting | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/arrays/majority-element.ts) |
| [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/) | Two Pointers | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/arrays/remove-duplicates.ts) |
| [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) | Sliding Window | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/arrays/best-time-to-buy-and-sell-stock.ts) |
| [Rotate Array](https://leetcode.com/problems/rotate-array/) | Array Rotation | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/arrays/rotate-array.ts) |
| [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/) | Prefix Product | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/arrays/product-of-array-except-self.ts) |
| [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/) | Greedy / Sliding Window | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/arrays/best-time-to-buy-and-sell-stock-ii.ts) |
| [Number of Zero-Filled Subarrays](https://leetcode.com/problems/number-of-zero-filled-subarrays/) | Counting | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/arrays/number-of-zero-filled-subarrays.ts) |
| [Increasing Triplet Subsequence](https://leetcode.com/problems/increasing-triplet-subsequence/) | Greedy | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/arrays/increasing-triplet-subsequence.ts) |
| [First Missing Positive](https://leetcode.com/problems/first-missing-positive/) | Index Mapping / In-Place Hashing | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/arrays/first-missing-positive.ts) |
