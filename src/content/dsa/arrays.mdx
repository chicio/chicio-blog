import { MemoryContiguityDiagram } from "../../components/sections/dsa/MemoryContiguityDiagram";
import { DynamicArrayVisualizer } from "../../components/sections/dsa/DynamicArrayVisualizer";
import { CacheLocalityDiagram } from "../../components/sections/dsa/CacheLocalityDiagram";
import { Accordion } from "../../components/sections/dsa/Accordion";

///https://www.geeksforgeeks.org/dsa/difference-between-static-arrays-and-dynamic-arrays/

# Arrays

Arrays are one of the most fundamental data structures in computer science. 
They provide a way to store elements in a contiguous block of memory, allowing efficient access and manipulation.

## What is an Array?

An **array** is a collection of elements identified by an index or a key, stored in contiguous memory locations.

### Static vs Dynamic Arrays

- **Static Arrays**: fixed size, allocated at compile-time (C, C++).  
- **Dynamic Arrays**: flexible size, can grow/shrink during execution (Python, Java, TypeScript, Swift, Kotlin).  

### Examples

Below you can find examples of both static and dynamic arrays in various programming languages.

#### Static Arrays

**C**  
```c
int arr[5] = {1, 2, 3, 4, 5};
```

**C++**  
```cpp
int arr[5] = {1, 2, 3, 4, 5};
```

#### Dynamic Arrays

**Java**  
```java
int[] arr = new int[5];
```

**Python**  
```python
arr = [1, 2, 3, 4, 5]
```

**TypeScript**  
```typescript
let arr: number[] = [1, 2, 3, 4, 5];
```

**Swift**  
```swift
var arr: [Int] = [1, 2, 3, 4, 5]
```

**Kotlin**  
```kotlin
val arr = arrayListOf(1, 2, 3, 4, 5)
```

## Operations and Time Complexity

| Operation       | Average Case | Worst Case |
|-----------------|--------------|------------|
| Access          | O(1)         | O(1)       |
| Search          | O(n)         | O(n)       |
| Insert (end)    | O(1)         | O(n)       |
| Insert (middle) | O(n)         | O(n)       |
| Delete (end)    | O(1)         | O(n)       |
| Delete (middle) | O(n)         | O(n)       |

<MemoryContiguityDiagram />

---

## Cache Locality and Performance

One reason arrays are **fast** is because of **cache locality**.  
Since elements are stored **contiguously**, the CPU can prefetch upcoming values efficiently.  

<CacheLocalityDiagram />

**Key Insight:** Iterating over an array is faster than traversing a linked list because the CPU cache works optimally with contiguous memory.

## Dynamic Array Growth

Dynamic arrays resize when capacity is reached.

<DynamicArrayVisualizer />

**Key Insight:** resizing is costly (O(n)), but happens infrequently, so average insertion remains O(1).

## Arrays as Building Blocks

Arrays form the foundation for other data structures:

- **Stack** (LIFO): push/pop on top of array.  
- **Queue** (FIFO): enqueue/dequeue using circular buffer.  
- **Hash Tables**: arrays for buckets.  
- **Heaps**: binary heap stored as array.  

For example below you can find a small example of a stack implemented using an array in Python:

```python
stack = []

stack.append(10) # push
stack.append(20)
print(stack.pop()) # pop => 20
```

## Techniques

Here are the main **array techniques** with descriptions and examples:

### Two-Pointer Technique
Used for problems involving pairs or subsequences.  
**Example**: Move Zeroes.

```python
def moveZeroes(nums):
    left = 0
    for right in range(len(nums)):
        if nums[right] != 0:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1
```

### Prefix Sum
Helps compute cumulative sums efficiently.  
**Example**: Product of Array Except Self.

### Sliding Window
For subarray/subsequence problems.  
**Example**: Best Time to Buy and Sell Stock.

### Hashing
Use hashmaps for frequency or fast lookup.  
**Example**: Majority Element.

### Sorting
Sometimes sorting simplifies the problem.  
**Example**: First Missing Positive.

<Accordion title="Why use these techniques?">
They are reusable blueprints for solving many array-related problems efficiently.
</Accordion>

## Exercises

Below is the full list of practice problems with solution links.

- [Move Zeroes](https://leetcode.com/problems/move-zeroes/) — *Two Pointers*  
  [Solution](https://github.com/your-github/leetcode-solutions)

- [Majority Element](https://leetcode.com/problems/majority-element/) — *Hashing / Boyer-Moore Voting*  
  [Solution](https://github.com/your-github/leetcode-solutions)

- [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/) — *Two Pointers*  
  [Solution](https://github.com/your-github/leetcode-solutions)

- [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) — *Sliding Window*  
  [Solution](https://github.com/your-github/leetcode-solutions)

- [Rotate Array](https://leetcode.com/problems/rotate-array/) — *Array Rotation*  
  [Solution](https://github.com/your-github/leetcode-solutions)

- [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/) — *Prefix Product*  
  [Solution](https://github.com/your-github/leetcode-solutions)

- [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/) — *Greedy / Sliding Window*  
  [Solution](https://github.com/your-github/leetcode-solutions)

- [Number of Zero-Filled Subarrays](https://leetcode.com/problems/number-of-zero-filled-subarrays/) — *Counting*  
  [Solution](https://github.com/your-github/leetcode-solutions)

- [Increasing Triplet Subsequence](https://leetcode.com/problems/increasing-triplet-subsequence/) — *Greedy*  
  [Solution](https://github.com/your-github/leetcode-solutions)

- [First Missing Positive](https://leetcode.com/problems/first-missing-positive/) — *Index Mapping / In-Place Hashing*  
  [Solution](https://github.com/your-github/leetcode-solutions)


## 9. Key Insights

- Arrays are **contiguous memory structures**.  
- Cache locality makes arrays faster than linked lists for iteration.  
- Dynamic arrays balance flexibility with resizing cost.  
- Arrays are **building blocks** for stacks, queues, heaps, and hash tables.  
- Techniques like **two pointers, prefix sums, sliding windows** are essential for array-based problem solving.
