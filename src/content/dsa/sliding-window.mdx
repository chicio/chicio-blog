# Sliding Window

The **Sliding Window** pattern is one of the most powerful techniques in algorithmic problem-solving.  
It transforms problems that would normally require **O(n²)** brute-force solutions into clean, efficient **O(n)** approaches by maintaining a “window” 
over a portion of the data and adjusting it as you process the input.

At its core, a sliding window lets you examine **contiguous segments** of an array or string without recomputing information from scratch every time.  
Instead of restarting from zero for each possible subarray or substring, you *reuse* previous computations and update the window incrementally.

Sliding window is ideal when the problem involves:

- **Contiguous subarrays / substrings**
- **Finding a best window** (max/min length, max/min sum, longest/shortest segment)
- **Counting or matching patterns within a range**
- **Maintaining a constraint** (e.g., “at most K zeros”, “all frequencies match”, “no repeated characters”)

If the problem involves checking or optimizing a **continuous segment** of a sequence, sliding window is often the correct approach.
Look for these signals in the problem statement:

- “Find the *longest/shortest* substring/subarray where…”
- “Find a window of size *k*…”
- “Count subarrays where the sum/average/number of distinct elements satisfies…”
- “Return all substrings that match a pattern…”
- “Find the minimum window that contains all characters…”

If the word **subarray** or **substring** appears—and the subarray must be **contiguous**—this is an immediate hint.

Usually, a naïve brute-force approach for the problems above checks every possible subarray:

```txt
for L in range(n):
for R in range(L, n):
check subarray nums[L:R]
```

This leads to:

- $O(n²)$ time to enumerate the subarrays  
- plus additional computation inside the inner loop

Sliding window avoids recomputing work.  
Instead, it grows or shrinks the window by **one step at a time**, preserving most of the previously computed information.
This transformation often reduces complexity to $O(n)$.

Sliding window is not just an optimization—it is a **paradigm shift** in how you iterate over collections.  
Once you recognize the structure of these problems, the sliding window template becomes your go-to tool for a whole class of subarray and substring challenges.


---

2. Sliding Window vs Two Pointers
	•	Conceptual differences
	•	Relationship between the two patterns
	•	When to use one vs the other

3. Types of Sliding Window

3.1 Fixed-Size Sliding Window
	•	Definition
	•	How it works
	•	Typical problem signals
	•	General template

3.2 Dynamic-Size Sliding Window
	•	Definition
	•	How it works (expand → validate → shrink)
	•	Typical constraints and invariants
	•	General template

4. Common Sliding Window Tools
	•	Frequency maps
	•	Running counters (sum, max, distinct counts, matches)
	•	Window validity conditions
	•	Strategies for shrinking the window

5. How to Recognize Sliding Window Problems
	•	Patterns in problem statements
	•	Key questions to identify the correct sliding window variant

6. Common Mistakes and How to Avoid Them
	•	Off-by-one errors
	•	Incorrect shrink conditions
	•	Mismanaging counts or frequencies
	•	Forgetting to update best results at the right moment

7. Time and Space Complexity
	•	Complexity of fixed-size windows
	•	Complexity of dynamic windows
	•	Why sliding window is almost always O(n)

8. Exercises list

Two sections merged into one list but maintaining categories:

8.1 Fixed-Size Sliding Window Exercises

| Problem | Technique | Link |

8.2 Dynamic-Size Sliding Window Exercises
