import { StackVisualizer } from "../../components/sections/dsa/components/stack-visualizer";
import { InteractiveBlock } from "../../components/sections/dsa/components/interactive-block";

# Stacks

A **stack** is a fundamental **LIFO (Last In, First Out)** data structure: this means that the **last element added** to the stack is the **first one to be removed**. 
You can think of it like a stack of plates: you always add new plates on top, and when you need a plate, you take the one on top first.

Stacks are simple yet powerful, and they form the basis for many algorithms and data structures. 
Their strength comes from the fact that operations are **always performed at one end**, called the **top of the stack**. 
This allows for **constant-time insertion and removal**, which can be very efficient compared to other data structures like arrays or linked lists for certain use cases.

There are three main operations in a stack:

- **Push**: Add an element to the top of the stack. Every new element goes on top, potentially hiding the elements below.
- **Pop**: Remove the element from the top of the stack. Only the top element can be removed at any time, enforcing the LIFO principle.
- **Peek / Top**: Inspect the element at the top without removing it. Useful to see what is currently “active” or to make decisions based on the most recent addition.

These operations make stacks ideal for **temporary storage** of data where you only care about the last item added, not the entire collection.

Stacks are often **implicit in algorithms**, even if you don’t see a formal stack object:

- **Backtracking problems**: keep track of choices or moves (e.g., solving a maze or generating permutations).  
- **Reversals**: reverse a sequence of elements by pushing them onto a stack and popping them in order.  
- **Nested structures**: parsing expressions, matching parentheses, or evaluating mathematical formulas (e.g., Reverse Polish Notation).  
- **Function calls**: programming languages use a call stack internally to track function calls and returns.

Stacks can be implemented using **arrays** or **linked lists**, but the key principle remains: **all operations are performed at the top**. 
This simplicity is why stacks are often a first step in algorithmic thinking, allowing you to manage data in a controlled, sequential manner.

```typescript
class Stack<T> {
  private items: T[] = [];

  push(element: T): void {
    this.items.push(element);
  }

  pop(): T | undefined {
    return this.items.pop();
  }

  peek(): T | undefined {
    return this.items[this.items.length - 1];
  }

  isEmpty(): boolean {
    return this.items.length === 0;
  }

  size(): number {
    return this.items.length;
  }
}
```

<InteractiveBlock title="Stack Visualization">
    <StackVisualizer />
</InteractiveBlock>

## Patterns

Stacks are not just a basic data structure. They encode a very specific way of thinking about problems.  
Whenever the logic of a problem depends on **what happened most recently**, or when elements must be processed in a **strictly reversed order**, 
stacks naturally emerge as the right abstraction.

Over time, a small number of recurring **stack patterns** appear again and again across very different problems. 
Recognizing these patterns is often the key step toward a clean and efficient solution.

### Matching & Balancing

One of the most common uses of stacks is to verify that elements are **properly matched and balanced**.  
These problems usually involve some notion of *opening* and *closing* elements, and correctness depends on the **order** in which they appear.

The core idea is simple: when you encounter an opening element, you push it onto the stack.  
When you encounter a closing element, you check whether it correctly matches the element on top of the stack. 
If it does, you pop the stack; if it doesn’t, the structure is invalid.

At the end of the process, the stack must be empty. Any leftover elements indicate that something was opened but never closed.

This pattern appears in problems such as validating parentheses, removing adjacent duplicates in strings, or computing the longest valid parentheses substring. 
In all of these cases, the crucial observation is that the **last opened element must be the first one to close**, which is exactly the LIFO behavior provided by a stack.

### Parsing & Evaluating Expressions

Stacks are also fundamental when dealing with **expression parsing and evaluation**, especially when operators and operands are interleaved.

In these problems, you typically process tokens from left to right. Operands are pushed onto the stack, while operators trigger computations using the most recent operands. 
Once a computation is performed, the result is pushed back onto the stack and may itself be used by later operators.

```typescript
const stack: string[] = [];

for (const ch of s) {
  if (ch === "(") {
    stack.push(ch);
  } else {
    if (stack.length === 0) { 
      return false;
    }
    stack.pop();
  }
}

return stack.length === 0;
```

This approach is particularly clear in postfix (Reverse Polish) notation, where operator precedence is encoded in the order of tokens rather than explicit parentheses. 
However, the same principle also applies to calculator-style problems where you must respect precedence rules while scanning the expression.

Stacks work well here because intermediate results must be remembered temporarily, and operators always depend on the **most recently seen operands**.

```typescript
const stack: number[] = [];

for (const token of tokens) {
  if (isNumber(token)) {
    stack.push(Number(token));
  } else {
    const b = stack.pop()!;
    const a = stack.pop()!;
    stack.push(applyOperator(a, b, token));
  }
}
```

### Backtracking and Undo Patterns

Another powerful application of stacks is modeling **backtracking and undo behavior**.

Any system where actions must be reversible, such as undoing edits, navigating backward through a history, or reverting to a previous state, can be naturally represented using a stack. 
Each action is pushed onto the stack as it happens. When an undo is required, the most recent action is popped and reverted.

```typescript
doAction(action)
stack.push(action)

//... other code

const last = stack.pop()
undo(last)
```

This idea extends beyond user interfaces. Many recursive algorithms, especially depth-first search, rely on an implicit call stack to keep track of execution state. 
Making this stack explicit often leads to iterative solutions that are easier to control and reason about.

The reason stacks fit so well here is intuitive: when undoing, you always revert the **last action first**, exactly matching the stack’s behavior.

## 3. Monotonic Stack
- Definition: a stack maintaining an increasing or decreasing invariant
- How it works: push while preserving order, pop when invariant violated
- Amortized O(n) guarantees
- Typical use cases: next greater/smaller, spans, max area/range

## 4. Common Tools and Techniques
- Frequency maps or auxiliary stacks if needed
- Maintaining invariants
- Running max/min while traversing
- Shrinking / expanding the stack conceptually

## 5. Time & Space Complexity
- Classic stack operations: O(1) time, O(n) space (for n elements)
- Monotonic stack: O(n) time (amortized), O(n) space

## 6. Exercises

| Problem | Technique | Solution |
|---------|-----------|----------|
| [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/) | Stack | Soon available |
| [Remove All Adjacent Duplicates in String](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/) | Stack | Soon available |
| [Min Stack](https://leetcode.com/problems/min-stack/) | Stack | Soon available |
| [Remove Duplicate Letters](https://leetcode.com/problems/remove-duplicate-letters/) | Stack | Soon available |
| [Removing Stars From a String](https://leetcode.com/problems/removing-stars-from-a-string/) | Stack | Soon available |
| [Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/) | Stack | Soon available |
| [Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/) | Stack | Soon available |
| [Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/) | Stack | Soon available |
| [Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/) | Monotonic Stack | Soon available |
| [Daily Temperatures](https://leetcode.com/problems/daily-temperatures/) | Monotonic Stack | Soon available |
| [Online Stock Span](https://leetcode.com/problems/online-stock-span/) | Monotonic Stack | Soon available |
| [132 Pattern](https://leetcode.com/problems/132-pattern/) | Monotonic Stack | Soon available |
| [Number of Visible People in a Queue](https://leetcode.com/problems/number-of-visible-people-in-a-queue/) | Monotonic Stack | Soon available |
| [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/) | Monotonic Stack | Soon available |