---
title: "Linked List"
description: "A linked list is a data structure consisting of nodes where each node contains a value and a reference to the next node, enabling flexible insertions and deletions."
tags: [linked list, data structures, algorithms]
authors: [fabrizio_duroni]
---

import { CourseNavigation } from "../../../components/sections/dsa/components/course-navigation";

# Linked list

A **linked list** is a data structure consisting of nodes, where each node contains a value and a reference (pointer) to the next node. Unlike arrays, linked lists 
do **not store elements contiguously** in memory. This makes insertion and deletion operations more flexible but requires careful pointer management.

Key points to keep in mind:

- The **head** points to the first element, and losing it can result in losing access to the entire list
- **Traversal** requires following `next` pointers until `null` is reached
- Linked lists can easily form **cycles**, which must be handled to avoid infinite loops
- Operations that are trivial in arrays, like accessing the i-th element, require **O(n)** traversal in linked lists

Understanding these fundamentals is crucial before diving into more advanced linked list patterns such as **two pointers**, **reversals**, and **cycle detection**.

## Operations

Before tackling advanced patterns, it’s important to master the basic operations on a linked list.
All the snippets below are based on a `ListNode` data structure with the following definition.

```typescript
class ListNode {
  val: number;
  next: ListNode | null;
  constructor(val: number) {
    this.val = val;
    this.next = null;
  }
}
```

When working with linked lists, edge cases often arise when inserting or deleting nodes at the head of the list. 
To handle these cases cleanly, we introduce a dummy node: a temporary node placed before the head. 
This allows all operations to be implemented uniformly, without special checks for the head.  

For traversing a linked list, you typically start from the head and follow the `next` pointers until you reach the end (`null`).

```typescript
function traverse(head: ListNode | null): void {
    const dummy = new ListNode(0);
    dummy.next = head;

    let curr: ListNode | null = dummy.next;

    while (curr) {
        console.log(curr.val);
        curr = curr.next;
    }
};
```

The same technique can be applied to other operations like insertion and deletion, making the code cleaner and easier to manage.
For example to insert a new node at a given position:

```typescript
function insertAtPosition(head: ListNode | null, val: number, pos: number): ListNode | null {
  const dummy = new ListNode(0);
  dummy.next = head;
  
  let prev: ListNode | null = dummy;
  let index = 0;

  while (prev && index < pos) {
    prev = prev.next;
    index++;
  }

  if (prev) {
    const newNode = new ListNode(val);
    newNode.next = prev.next;
    prev.next = newNode;
  }

  return dummy.next;
}
```     

The same dummy node approach can be used for deletion by adjusting the `next` pointers to skip over the target node:

```typescript
function deleteByValue(head: ListNode | null, target: number): ListNode | null {
  const dummy = new ListNode(0);
  dummy.next = head;

  let prev: ListNode | null = dummy;
  let curr: ListNode | null = dummy.next;

  while (curr) {
    if (curr.val === target) {
      prev!.next = curr.next;
      break;
    }

    prev = curr;
    curr = curr.next;
  }

  return dummy.next;
}
```

## Reversal Techniques

Reversing a linked list (fully or partially) is one of the most important skills when working with linked lists.
A lot of problems require reversing the entire list or a portion of it.

The algorithm to reverse a linked list involves three main steps:
- Iterate through the list
- Reverse the next pointer of each node
- Move forward while keeping track of the previous node

```typescript
function reverseList(head: ListNode | null): ListNode | null {
  let prev: ListNode | null = null;
  let curr: ListNode | null = head;

  while (curr !== null) {
    const nextTemp = curr.next;
    curr.next = prev;
    prev = curr;
    curr = nextTemp;
  }

  return prev;
}
```

For partial reversal, such as reversing a sublist from position `m` to `n`, we can use a similar approach but with additional pointers to manage the boundaries of the sublist.

```typescript
function reverseBetween(
  head: ListNode | null,
  m: number,
  n: number
): ListNode | null {
  const dummy = new ListNode(0);
  dummy.next = head;

  let prev: ListNode | null = dummy;

  for (let i = 1; i < m; i++) {
    prev = prev!.next;
  }

  let start = prev!.next; // first node of the sublist
  let then = start!.next; // node to be repositioned

  for (let i = 0; i < n - m; i++) {
    start!.next = then!.next;
    then!.next = prev!.next;
    prev!.next = then;
    then = start!.next;
  }

  return dummy.next;
}
```

## Detecting Cycles (Floyd’s Cycle Finding Algorithm)

Cycle detection is a classic linked list problem: given a list, determine whether a node eventually points back to a previous one. 
The most common and efficient solution is Floyd’s Cycle Finding Algorithm, also known as the Tortoise and Hare approach.

Use two pointers:
- slow moves one step at a time
- fast moves two steps at a time
- if a cycle exists, the two pointers will eventually meet
- if fast reaches the end, the list has no cycle

Once a cycle is detected, it is possible to find the starting node of the cycle by:
- reset one pointer to the head
- move both pointers one step at a time
- the point where they meet again is the start of the cycle

```typescript
function hasCycle(head: ListNode | null): boolean {
  let slow = head;
  let fast = head;

  while (fast !== null && fast.next !== null) {
    slow = slow!.next;
    fast = fast.next.next;

    if (slow === fast) {
      return true;
    }
  }

  return false;
}
```

## Time & Space Complexity

Linked lists trade constant-time pointer manipulation for linear-time traversal.
Understanding where each cost comes from is essential to choosing the right data structure and technique.

| Operation / Pattern | Time Complexity | Space Complexity |
|---------------------|-----------------|------------------|
| Traverse list | O(n) | O(1) |
| Insert at head | O(1) | O(1) |
| Insert at tail | O(n) | O(1) |
| Insert at position (with dummy node) | O(n) | O(1) |
| Delete by value (with dummy node) | O(n) | O(1) |
| Reverse linked list | O(n) | O(1) |
| Reverse sublist (m → n) | O(n) | O(1) |
| Cycle detection (Floyd’s algorithm) | O(n) | O(1) |

## Exercises

| Problem | Technique | Solution |
|--------|----------|----------|
| [Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/) | Pointer Traversal | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/linked-list/intersection-of-two-linked-lists.ts) |
| [Design Linked List](https://leetcode.com/problems/design-linked-list/) | Linked List Design | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/linked-list/design-linked-list.ts) |
| [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) | Two Pointers + Dummy Node | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/linked-list/remove-nth-node-from-end-of-list.ts) |
| [Remove Duplicates from Sorted List II](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/) | Dummy Node + Traversal | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/linked-list/remove-duplicates-from-sorted-list-II.ts) |
| [Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/) | Pointer Manipulation | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/linked-list/swap-nodes-in-pairs.ts) |
| [Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/) | Hash Map / In-place Weaving | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/linked-list/copy-list-with-random-pointer.ts) |
| [Partition List](https://leetcode.com/problems/partition-list/) | Two Lists + Merge | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/linked-list/partition-list.ts) |
| [Rotate List](https://leetcode.com/problems/rotate-list/) | Pointer Traversal + Modulo | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/linked-list/rotate-list.ts) |
| [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/) | Digit-by-Digit Addition | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/linked-list/add-two-numbers.ts) |
| [Flatten a Multilevel Doubly Linked List](https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/) | DFS / Stack | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/linked-list/flatten-a-multilevel-doubly-linked-list.ts) |
| [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) | In-place Reversal | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/linkedList-in-place-reversal/reverse-linked-list.ts) |
| [Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) | Sublist Reversal + Dummy Node | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/linkedList-in-place-reversal/reverse-linked-list-II.ts) |
| [Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/) | Group Reversal | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/linkedList-in-place-reversal/reverse-nodes-in-k-group.ts) |
| [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/) | Reverse Second Half | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/linkedList-in-place-reversal/palindrome-linked-list.ts) |
| [Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/) | Fast & Slow Pointers | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/fast-and-slow-pointers/middle-of-the-linked-list.ts) |
| [Happy Number](https://leetcode.com/problems/happy-number/) | Floyd’s Cycle Detection | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/fast-and-slow-pointers/happy-number.ts) |
| [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) | Floyd’s Algorithm | [Solution](https://github.com/chicio/Algomaster-Solutions/blob/main/src/fast-and-slow-pointers/linked-list-cycle-II.ts) |
