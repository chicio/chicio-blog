---
title: "Quick Sort and Quick Select"
description: "An in-depth look at Quick Sort and Quick Select as divide-and-conquer algorithms, focusing on partitioning, expected complexity, and selection problems."
date: 2026-02-05
image: /images/posts/data-structures-and-algorithms-featured.png
tags: [quick sort, quick select, data structures, algorithms]
authors: [fabrizio_duroni]
---

# Quick Sort

Quick Sort is often presented as one of the fastest comparison-based sorting algorithms in practice, despite having a theoretical worst-case 
time complexity of $O(n^2)$.
This apparent contradiction is usually resolved with a brief mention of randomness or average-case analysis, and then quickly forgotten.
However, reducing Quick Sort to a performance anecdote misses the core reason why the algorithm is worth studying in depth.

At a structural level, Quick Sort is another instance of the divide and conquerï¿¼ paradigm, but it applies it in a markedly different way compared to Merge Sort.
Instead of deferring all meaningful work to the phase where partial results are combined, Quick Sort concentrates almost all of its algorithmic 
responsibility in the divide step itself.
The array is partitioned around a chosen pivot element, and this single operation enforces a strong global ordering constraint before any recursive call is made.

This design choice leads to two important consequences.
First, Quick Sort performs the sorting in place, without allocating auxiliary arrays to combine results.
Second, once the partitioning step is completed, the pivot element is already in its final position, and never needs to be moved again.
The recursive calls that follow operate on strictly smaller subarrays, each of which can be processed independently.

Unlike Merge Sort, the shape of the recursion tree in Quick Sort is not fixed.
It depends on how balanced the partitions are, which in turn depends on the pivot selection strategy and the input distribution.
This sensitivity introduces the possibility of highly unbalanced recursion, and therefore a quadratic worst case.
At the same time, it is precisely this flexibility that allows Quick Sort to achieve excellent cache locality and outstanding performance in real-world scenarios.

For these reasons, Quick Sort should not be studied merely as a faster alternative to Merge Sort.
It represents a different way of thinking about divide and conquer, where ordering constraints are established early and propagated downward through recursion.
Understanding this perspective is essential not only to reason about the algorithm itself, but also to recognize how the same structural idea naturally extends to selection problems, such as finding the k-th largest element in an array, without fully sorting the data.